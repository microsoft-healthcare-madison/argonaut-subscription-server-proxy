// <auto-generated />
// Built from: hl7.fhir.r5.core version: 4.6.0
  // Option: "NAMESPACE" = "fhirCsR5"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR5.Serialization;

namespace fhirCsR5.Models
{
  /// <summary>
  /// Indicates who performed the immunization event.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ImmunizationPerformer>))]
  public class ImmunizationPerformer : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// When the individual practitioner who performed the action is known, it is best to send.
    /// </summary>
    public Reference Actor { get; set; }
    /// <summary>
    /// Describes the type of performance (e.g. ordering provider, administering provider, etc.).
    /// </summary>
    public CodeableConcept Function { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (Function != null)
      {
        writer.WritePropertyName("function");
        Function.SerializeJson(writer, options);
      }

      if (Actor != null)
      {
        writer.WritePropertyName("actor");
        Actor.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "actor":
          Actor = new fhirCsR5.Models.Reference();
          Actor.DeserializeJson(ref reader, options);
          break;

        case "function":
          Function = new fhirCsR5.Models.CodeableConcept();
          Function.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Educational material presented to the patient (or guardian) at the time of vaccine administration.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ImmunizationEducation>))]
  public class ImmunizationEducation : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Identifier of the material presented to the patient.
    /// </summary>
    public string DocumentType { get; set; }
    /// <summary>
    /// Extension container element for DocumentType
    /// </summary>
    public Element _DocumentType { get; set; }
    /// <summary>
    /// Date the educational material was given to the patient.
    /// </summary>
    public string PresentationDate { get; set; }
    /// <summary>
    /// Extension container element for PresentationDate
    /// </summary>
    public Element _PresentationDate { get; set; }
    /// <summary>
    /// Date the educational material was published.
    /// </summary>
    public string PublicationDate { get; set; }
    /// <summary>
    /// Extension container element for PublicationDate
    /// </summary>
    public Element _PublicationDate { get; set; }
    /// <summary>
    /// Reference pointer to the educational material given to the patient if the information was on line.
    /// </summary>
    public string Reference { get; set; }
    /// <summary>
    /// Extension container element for Reference
    /// </summary>
    public Element _Reference { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(DocumentType))
      {
        writer.WriteString("documentType", (string)DocumentType!);
      }

      if (_DocumentType != null)
      {
        writer.WritePropertyName("_documentType");
        _DocumentType.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Reference))
      {
        writer.WriteString("reference", (string)Reference!);
      }

      if (_Reference != null)
      {
        writer.WritePropertyName("_reference");
        _Reference.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PublicationDate))
      {
        writer.WriteString("publicationDate", (string)PublicationDate!);
      }

      if (_PublicationDate != null)
      {
        writer.WritePropertyName("_publicationDate");
        _PublicationDate.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(PresentationDate))
      {
        writer.WriteString("presentationDate", (string)PresentationDate!);
      }

      if (_PresentationDate != null)
      {
        writer.WritePropertyName("_presentationDate");
        _PresentationDate.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "documentType":
          DocumentType = reader.GetString();
          break;

        case "_documentType":
          _DocumentType = new fhirCsR5.Models.Element();
          _DocumentType.DeserializeJson(ref reader, options);
          break;

        case "presentationDate":
          PresentationDate = reader.GetString();
          break;

        case "_presentationDate":
          _PresentationDate = new fhirCsR5.Models.Element();
          _PresentationDate.DeserializeJson(ref reader, options);
          break;

        case "publicationDate":
          PublicationDate = reader.GetString();
          break;

        case "_publicationDate":
          _PublicationDate = new fhirCsR5.Models.Element();
          _PublicationDate.DeserializeJson(ref reader, options);
          break;

        case "reference":
          Reference = reader.GetString();
          break;

        case "_reference":
          _Reference = new fhirCsR5.Models.Element();
          _Reference.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// A reaction may be an indication of an allergy or intolerance and, if this is determined to be the case, it should be recorded as a new AllergyIntolerance resource instance as most systems will not query against past Immunization.reaction elements.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ImmunizationReaction>))]
  public class ImmunizationReaction : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Date of reaction to the immunization.
    /// </summary>
    public string Date { get; set; }
    /// <summary>
    /// Extension container element for Date
    /// </summary>
    public Element _Date { get; set; }
    /// <summary>
    /// Details of the reaction.
    /// </summary>
    public Reference Detail { get; set; }
    /// <summary>
    /// Self-reported indicator.
    /// </summary>
    public bool? Reported { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Date))
      {
        writer.WriteString("date", (string)Date!);
      }

      if (_Date != null)
      {
        writer.WritePropertyName("_date");
        _Date.SerializeJson(writer, options);
      }

      if (Detail != null)
      {
        writer.WritePropertyName("detail");
        Detail.SerializeJson(writer, options);
      }

      if (Reported != null)
      {
        writer.WriteBoolean("reported", (bool)Reported!);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "date":
          Date = reader.GetString();
          break;

        case "_date":
          _Date = new fhirCsR5.Models.Element();
          _Date.DeserializeJson(ref reader, options);
          break;

        case "detail":
          Detail = new fhirCsR5.Models.Reference();
          Detail.DeserializeJson(ref reader, options);
          break;

        case "reported":
          Reported = reader.GetBoolean();
          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// The protocol (set of recommendations) being followed by the provider who administered the dose.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<ImmunizationProtocolApplied>))]
  public class ImmunizationProtocolApplied : BackboneElement,  IFhirJsonSerializable {
    /// <summary>
    /// Indicates the authority who published the protocol (e.g. ACIP) that is being followed.
    /// </summary>
    public Reference Authority { get; set; }
    /// <summary>
    /// The use of an integer is preferred if known. Text should only be used in cases where an integer is not available (such as when documenting a recurring booster dose).
    /// </summary>
    public string DoseNumber { get; set; }
    /// <summary>
    /// Extension container element for DoseNumber
    /// </summary>
    public Element _DoseNumber { get; set; }
    /// <summary>
    /// One possible path to achieve presumed immunity against a disease - within the context of an authority.
    /// </summary>
    public string Series { get; set; }
    /// <summary>
    /// Extension container element for Series
    /// </summary>
    public Element _Series { get; set; }
    /// <summary>
    /// The use of an integer is preferred if known.
    /// </summary>
    public string SeriesDoses { get; set; }
    /// <summary>
    /// Extension container element for SeriesDoses
    /// </summary>
    public Element _SeriesDoses { get; set; }
    /// <summary>
    /// The vaccine preventable disease the dose is being administered against.
    /// </summary>
    public List<CodeableConcept> TargetDisease { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      ((fhirCsR5.Models.BackboneElement)this).SerializeJson(writer, options, false);

      if (!string.IsNullOrEmpty(Series))
      {
        writer.WriteString("series", (string)Series!);
      }

      if (_Series != null)
      {
        writer.WritePropertyName("_series");
        _Series.SerializeJson(writer, options);
      }

      if (Authority != null)
      {
        writer.WritePropertyName("authority");
        Authority.SerializeJson(writer, options);
      }

      if ((TargetDisease != null) && (TargetDisease.Count != 0))
      {
        writer.WritePropertyName("targetDisease");
        writer.WriteStartArray();

        foreach (CodeableConcept valTargetDisease in TargetDisease)
        {
          valTargetDisease.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(DoseNumber))
      {
        writer.WriteString("doseNumber", (string)DoseNumber!);
      }

      if (_DoseNumber != null)
      {
        writer.WritePropertyName("_doseNumber");
        _DoseNumber.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(SeriesDoses))
      {
        writer.WriteString("seriesDoses", (string)SeriesDoses!);
      }

      if (_SeriesDoses != null)
      {
        writer.WritePropertyName("_seriesDoses");
        _SeriesDoses.SerializeJson(writer, options);
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "authority":
          Authority = new fhirCsR5.Models.Reference();
          Authority.DeserializeJson(ref reader, options);
          break;

        case "doseNumber":
          DoseNumber = reader.GetString();
          break;

        case "_doseNumber":
          _DoseNumber = new fhirCsR5.Models.Element();
          _DoseNumber.DeserializeJson(ref reader, options);
          break;

        case "series":
          Series = reader.GetString();
          break;

        case "_series":
          _Series = new fhirCsR5.Models.Element();
          _Series.DeserializeJson(ref reader, options);
          break;

        case "seriesDoses":
          SeriesDoses = reader.GetString();
          break;

        case "_seriesDoses":
          _SeriesDoses = new fhirCsR5.Models.Element();
          _SeriesDoses.DeserializeJson(ref reader, options);
          break;

        case "targetDisease":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          TargetDisease = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objTargetDisease = new fhirCsR5.Models.CodeableConcept();
            objTargetDisease.DeserializeJson(ref reader, options);
            TargetDisease.Add(objTargetDisease);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (TargetDisease.Count == 0)
          {
            TargetDisease = null;
          }

          break;

        default:
          ((fhirCsR5.Models.BackboneElement)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Describes the event of a patient being administered a vaccine or a record of an immunization as reported by a patient, a clinician or another party.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<Immunization>))]
  public class Immunization : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "Immunization";
    /// <summary>
    /// Allows tracing of an authorization for the Immunization.
    /// </summary>
    public List<Reference> BasedOn { get; set; }
    /// <summary>
    /// The quantity of vaccine product that was administered.
    /// </summary>
    public Quantity DoseQuantity { get; set; }
    /// <summary>
    /// Educational material presented to the patient (or guardian) at the time of vaccine administration.
    /// </summary>
    public List<ImmunizationEducation> Education { get; set; }
    /// <summary>
    /// The visit or admission or other contact between patient and health care provider the immunization was performed as part of.
    /// </summary>
    public Reference Encounter { get; set; }
    /// <summary>
    /// Date vaccine batch expires.
    /// </summary>
    public string ExpirationDate { get; set; }
    /// <summary>
    /// Extension container element for ExpirationDate
    /// </summary>
    public Element _ExpirationDate { get; set; }
    /// <summary>
    /// Indicates the source of the vaccine actually administered. This may be different than the patient eligibility (e.g. the patient may be eligible for a publically purchased vaccine but due to inventory issues, vaccine purchased with private funds was actually administered).
    /// </summary>
    public CodeableConcept FundingSource { get; set; }
    /// <summary>
    /// A unique identifier assigned to this immunization record.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// Typically will not be populated if primarySource = True, not required even if primarySource = False.
    /// </summary>
    public CodeableConcept InformationSourceCodeableConcept { get; set; }
    /// <summary>
    /// Typically will not be populated if primarySource = True, not required even if primarySource = False.
    /// </summary>
    public Reference InformationSourceReference { get; set; }
    /// <summary>
    /// The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Immunization.
    /// </summary>
    public List<string> InstantiatesCanonical { get; set; }
    /// <summary>
    /// Extension container element for InstantiatesCanonical
    /// </summary>
    public List<Element> _InstantiatesCanonical { get; set; }
    /// <summary>
    /// This might be an HTML page, PDF, etc. or could just be a non-resolvable URI identifier.
    /// </summary>
    public List<string> InstantiatesUri { get; set; }
    /// <summary>
    /// Extension container element for InstantiatesUri
    /// </summary>
    public List<Element> _InstantiatesUri { get; set; }
    /// <summary>
    /// Typically, the recognition of the dose being sub-potent is retrospective, after the administration (ex. notification of a manufacturer recall after administration). However, in the case of a partial administration (the patient moves unexpectedly and only some of the dose is actually administered), subpotency may be recognized immediately, but it is still important to record the event.
    /// </summary>
    public bool? IsSubpotent { get; set; }
    /// <summary>
    /// The service delivery location where the vaccine administration occurred.
    /// </summary>
    public Reference Location { get; set; }
    /// <summary>
    /// Lot number of the  vaccine product.
    /// </summary>
    public string LotNumber { get; set; }
    /// <summary>
    /// Extension container element for LotNumber
    /// </summary>
    public Element _LotNumber { get; set; }
    /// <summary>
    /// Name of vaccine manufacturer.
    /// </summary>
    public Reference Manufacturer { get; set; }
    /// <summary>
    /// Extra information about the immunization that is not conveyed by the other attributes.
    /// </summary>
    public List<Annotation> Note { get; set; }
    /// <summary>
    /// When immunizations are given a specific date and time should always be known.   When immunizations are patient reported, a specific date might not be known.  Although partial dates are allowed, an adult patient might not be able to recall the year a childhood immunization was given. An exact date is always preferable, but the use of the String data type is acceptable when an exact date is not known. A small number of vaccines (e.g. live oral typhoid vaccine) are given as a series of patient self-administered dose over a span of time. In cases like this, often, only the first dose (typically a provider supervised dose) is recorded with the occurrence indicating the date/time of the first dose.
    /// </summary>
    public string OccurrenceDateTime { get; set; }
    /// <summary>
    /// Extension container element for OccurrenceDateTime
    /// </summary>
    public Element _OccurrenceDateTime { get; set; }
    /// <summary>
    /// When immunizations are given a specific date and time should always be known.   When immunizations are patient reported, a specific date might not be known.  Although partial dates are allowed, an adult patient might not be able to recall the year a childhood immunization was given. An exact date is always preferable, but the use of the String data type is acceptable when an exact date is not known. A small number of vaccines (e.g. live oral typhoid vaccine) are given as a series of patient self-administered dose over a span of time. In cases like this, often, only the first dose (typically a provider supervised dose) is recorded with the occurrence indicating the date/time of the first dose.
    /// </summary>
    public string OccurrenceString { get; set; }
    /// <summary>
    /// Extension container element for OccurrenceString
    /// </summary>
    public Element _OccurrenceString { get; set; }
    /// <summary>
    /// The patient who either received or did not receive the immunization.
    /// </summary>
    public Reference Patient { get; set; }
    /// <summary>
    /// Indicates who performed the immunization event.
    /// </summary>
    public List<ImmunizationPerformer> Performer { get; set; }
    /// <summary>
    /// Reflects the “reliability” of the content.
    /// </summary>
    public bool? PrimarySource { get; set; }
    /// <summary>
    /// Indicates a patient's eligibility for a funding program.
    /// </summary>
    public List<CodeableConcept> ProgramEligibility { get; set; }
    /// <summary>
    /// The protocol (set of recommendations) being followed by the provider who administered the dose.
    /// </summary>
    public List<ImmunizationProtocolApplied> ProtocolApplied { get; set; }
    /// <summary>
    /// A reaction may be an indication of an allergy or intolerance and, if this is determined to be the case, it should be recorded as a new AllergyIntolerance resource instance as most systems will not query against past Immunization.reaction elements.
    /// </summary>
    public List<ImmunizationReaction> Reaction { get; set; }
    /// <summary>
    /// Describes why the immunization occurred in coded or textual form, or Indicates another resource (Condition, Observation or DiagnosticReport) whose existence justifies this immunization.
    /// </summary>
    public List<CodeableReference> Reason { get; set; }
    /// <summary>
    /// The date the occurrence of the immunization was first captured in the record - potentially significantly after the occurrence of the event.
    /// </summary>
    public string Recorded { get; set; }
    /// <summary>
    /// Extension container element for Recorded
    /// </summary>
    public Element _Recorded { get; set; }
    /// <summary>
    /// The path by which the vaccine product is taken into the body.
    /// </summary>
    public CodeableConcept Route { get; set; }
    /// <summary>
    /// Body site where vaccine was administered.
    /// </summary>
    public CodeableConcept Site { get; set; }
    /// <summary>
    /// Will generally be set to show that the immunization has been completed or not done.  This element is labeled as a modifier because the status contains codes that mark the resource as not currently valid.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// This is generally only used for the status of "not-done". The reason for performing the immunization event is captured in reasonCode, not here.
    /// </summary>
    public CodeableConcept StatusReason { get; set; }
    /// <summary>
    /// Reason why a dose is considered to be subpotent.
    /// </summary>
    public List<CodeableConcept> SubpotentReason { get; set; }
    /// <summary>
    /// The code for the administered vaccine may be reported at various levels of granularity from a very generic code for a general type of vaccine (e.g. the SNOMED or CVX code for the flu vaccine) to a very discrete code for a specific product including the form and packaging (e.g. an NDC code). Because vaccineCode uses the CodeableConcept data type, multiple codes at different levels of granularity may be reported for a single immunization event provided that all codes are appropriate for the same vaccine. For example, both NDC and CVX codes may be provided for a given immunization event by repeating the coding element within vaccineCode.
    /// </summary>
    public CodeableConcept VaccineCode { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR5.Models.DomainResource)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((InstantiatesCanonical != null) && (InstantiatesCanonical.Count != 0))
      {
        writer.WritePropertyName("instantiatesCanonical");
        writer.WriteStartArray();

        foreach (string valInstantiatesCanonical in InstantiatesCanonical)
        {
          writer.WriteStringValue(valInstantiatesCanonical);
        }

        writer.WriteEndArray();
      }

      if ((_InstantiatesCanonical != null) && (_InstantiatesCanonical.Count != 0))
      {
        writer.WritePropertyName("_instantiatesCanonical");
        writer.WriteStartArray();

        foreach (Element val_InstantiatesCanonical in _InstantiatesCanonical)
        {
          val_InstantiatesCanonical.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((InstantiatesUri != null) && (InstantiatesUri.Count != 0))
      {
        writer.WritePropertyName("instantiatesUri");
        writer.WriteStartArray();

        foreach (string valInstantiatesUri in InstantiatesUri)
        {
          writer.WriteStringValue(valInstantiatesUri);
        }

        writer.WriteEndArray();
      }

      if ((_InstantiatesUri != null) && (_InstantiatesUri.Count != 0))
      {
        writer.WritePropertyName("_instantiatesUri");
        writer.WriteStartArray();

        foreach (Element val_InstantiatesUri in _InstantiatesUri)
        {
          val_InstantiatesUri.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((BasedOn != null) && (BasedOn.Count != 0))
      {
        writer.WritePropertyName("basedOn");
        writer.WriteStartArray();

        foreach (Reference valBasedOn in BasedOn)
        {
          valBasedOn.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if (StatusReason != null)
      {
        writer.WritePropertyName("statusReason");
        StatusReason.SerializeJson(writer, options);
      }

      if (VaccineCode != null)
      {
        writer.WritePropertyName("vaccineCode");
        VaccineCode.SerializeJson(writer, options);
      }

      if (Manufacturer != null)
      {
        writer.WritePropertyName("manufacturer");
        Manufacturer.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(LotNumber))
      {
        writer.WriteString("lotNumber", (string)LotNumber!);
      }

      if (_LotNumber != null)
      {
        writer.WritePropertyName("_lotNumber");
        _LotNumber.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(ExpirationDate))
      {
        writer.WriteString("expirationDate", (string)ExpirationDate!);
      }

      if (_ExpirationDate != null)
      {
        writer.WritePropertyName("_expirationDate");
        _ExpirationDate.SerializeJson(writer, options);
      }

      if (Patient != null)
      {
        writer.WritePropertyName("patient");
        Patient.SerializeJson(writer, options);
      }

      if (Encounter != null)
      {
        writer.WritePropertyName("encounter");
        Encounter.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(OccurrenceDateTime))
      {
        writer.WriteString("occurrenceDateTime", (string)OccurrenceDateTime!);
      }

      if (_OccurrenceDateTime != null)
      {
        writer.WritePropertyName("_occurrenceDateTime");
        _OccurrenceDateTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(OccurrenceString))
      {
        writer.WriteString("occurrenceString", (string)OccurrenceString!);
      }

      if (_OccurrenceString != null)
      {
        writer.WritePropertyName("_occurrenceString");
        _OccurrenceString.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(Recorded))
      {
        writer.WriteString("recorded", (string)Recorded!);
      }

      if (_Recorded != null)
      {
        writer.WritePropertyName("_recorded");
        _Recorded.SerializeJson(writer, options);
      }

      if (PrimarySource != null)
      {
        writer.WriteBoolean("primarySource", (bool)PrimarySource!);
      }

      if (InformationSourceCodeableConcept != null)
      {
        writer.WritePropertyName("informationSourceCodeableConcept");
        InformationSourceCodeableConcept.SerializeJson(writer, options);
      }

      if (InformationSourceReference != null)
      {
        writer.WritePropertyName("informationSourceReference");
        InformationSourceReference.SerializeJson(writer, options);
      }

      if (Location != null)
      {
        writer.WritePropertyName("location");
        Location.SerializeJson(writer, options);
      }

      if (Site != null)
      {
        writer.WritePropertyName("site");
        Site.SerializeJson(writer, options);
      }

      if (Route != null)
      {
        writer.WritePropertyName("route");
        Route.SerializeJson(writer, options);
      }

      if (DoseQuantity != null)
      {
        writer.WritePropertyName("doseQuantity");
        DoseQuantity.SerializeJson(writer, options);
      }

      if ((Performer != null) && (Performer.Count != 0))
      {
        writer.WritePropertyName("performer");
        writer.WriteStartArray();

        foreach (ImmunizationPerformer valPerformer in Performer)
        {
          valPerformer.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Note != null) && (Note.Count != 0))
      {
        writer.WritePropertyName("note");
        writer.WriteStartArray();

        foreach (Annotation valNote in Note)
        {
          valNote.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Reason != null) && (Reason.Count != 0))
      {
        writer.WritePropertyName("reason");
        writer.WriteStartArray();

        foreach (CodeableReference valReason in Reason)
        {
          valReason.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (IsSubpotent != null)
      {
        writer.WriteBoolean("isSubpotent", (bool)IsSubpotent!);
      }

      if ((SubpotentReason != null) && (SubpotentReason.Count != 0))
      {
        writer.WritePropertyName("subpotentReason");
        writer.WriteStartArray();

        foreach (CodeableConcept valSubpotentReason in SubpotentReason)
        {
          valSubpotentReason.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((Education != null) && (Education.Count != 0))
      {
        writer.WritePropertyName("education");
        writer.WriteStartArray();

        foreach (ImmunizationEducation valEducation in Education)
        {
          valEducation.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ProgramEligibility != null) && (ProgramEligibility.Count != 0))
      {
        writer.WritePropertyName("programEligibility");
        writer.WriteStartArray();

        foreach (CodeableConcept valProgramEligibility in ProgramEligibility)
        {
          valProgramEligibility.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (FundingSource != null)
      {
        writer.WritePropertyName("fundingSource");
        FundingSource.SerializeJson(writer, options);
      }

      if ((Reaction != null) && (Reaction.Count != 0))
      {
        writer.WritePropertyName("reaction");
        writer.WriteStartArray();

        foreach (ImmunizationReaction valReaction in Reaction)
        {
          valReaction.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((ProtocolApplied != null) && (ProtocolApplied.Count != 0))
      {
        writer.WritePropertyName("protocolApplied");
        writer.WriteStartArray();

        foreach (ImmunizationProtocolApplied valProtocolApplied in ProtocolApplied)
        {
          valProtocolApplied.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "basedOn":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          BasedOn = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objBasedOn = new fhirCsR5.Models.Reference();
            objBasedOn.DeserializeJson(ref reader, options);
            BasedOn.Add(objBasedOn);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (BasedOn.Count == 0)
          {
            BasedOn = null;
          }

          break;

        case "doseQuantity":
          DoseQuantity = new fhirCsR5.Models.Quantity();
          DoseQuantity.DeserializeJson(ref reader, options);
          break;

        case "education":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Education = new List<ImmunizationEducation>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ImmunizationEducation objEducation = new fhirCsR5.Models.ImmunizationEducation();
            objEducation.DeserializeJson(ref reader, options);
            Education.Add(objEducation);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Education.Count == 0)
          {
            Education = null;
          }

          break;

        case "encounter":
          Encounter = new fhirCsR5.Models.Reference();
          Encounter.DeserializeJson(ref reader, options);
          break;

        case "expirationDate":
          ExpirationDate = reader.GetString();
          break;

        case "_expirationDate":
          _ExpirationDate = new fhirCsR5.Models.Element();
          _ExpirationDate.DeserializeJson(ref reader, options);
          break;

        case "fundingSource":
          FundingSource = new fhirCsR5.Models.CodeableConcept();
          FundingSource.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Identifier objIdentifier = new fhirCsR5.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "informationSourceCodeableConcept":
          InformationSourceCodeableConcept = new fhirCsR5.Models.CodeableConcept();
          InformationSourceCodeableConcept.DeserializeJson(ref reader, options);
          break;

        case "informationSourceReference":
          InformationSourceReference = new fhirCsR5.Models.Reference();
          InformationSourceReference.DeserializeJson(ref reader, options);
          break;

        case "instantiatesCanonical":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          InstantiatesCanonical = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            InstantiatesCanonical.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (InstantiatesCanonical.Count == 0)
          {
            InstantiatesCanonical = null;
          }

          break;

        case "_instantiatesCanonical":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _InstantiatesCanonical = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Element obj_InstantiatesCanonical = new fhirCsR5.Models.Element();
            obj_InstantiatesCanonical.DeserializeJson(ref reader, options);
            _InstantiatesCanonical.Add(obj_InstantiatesCanonical);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_InstantiatesCanonical.Count == 0)
          {
            _InstantiatesCanonical = null;
          }

          break;

        case "instantiatesUri":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          InstantiatesUri = new List<string>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            InstantiatesUri.Add(reader.GetString());

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (InstantiatesUri.Count == 0)
          {
            InstantiatesUri = null;
          }

          break;

        case "_instantiatesUri":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          _InstantiatesUri = new List<Element>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Element obj_InstantiatesUri = new fhirCsR5.Models.Element();
            obj_InstantiatesUri.DeserializeJson(ref reader, options);
            _InstantiatesUri.Add(obj_InstantiatesUri);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (_InstantiatesUri.Count == 0)
          {
            _InstantiatesUri = null;
          }

          break;

        case "isSubpotent":
          IsSubpotent = reader.GetBoolean();
          break;

        case "location":
          Location = new fhirCsR5.Models.Reference();
          Location.DeserializeJson(ref reader, options);
          break;

        case "lotNumber":
          LotNumber = reader.GetString();
          break;

        case "_lotNumber":
          _LotNumber = new fhirCsR5.Models.Element();
          _LotNumber.DeserializeJson(ref reader, options);
          break;

        case "manufacturer":
          Manufacturer = new fhirCsR5.Models.Reference();
          Manufacturer.DeserializeJson(ref reader, options);
          break;

        case "note":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Note = new List<Annotation>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Annotation objNote = new fhirCsR5.Models.Annotation();
            objNote.DeserializeJson(ref reader, options);
            Note.Add(objNote);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Note.Count == 0)
          {
            Note = null;
          }

          break;

        case "occurrenceDateTime":
          OccurrenceDateTime = reader.GetString();
          break;

        case "_occurrenceDateTime":
          _OccurrenceDateTime = new fhirCsR5.Models.Element();
          _OccurrenceDateTime.DeserializeJson(ref reader, options);
          break;

        case "occurrenceString":
          OccurrenceString = reader.GetString();
          break;

        case "_occurrenceString":
          _OccurrenceString = new fhirCsR5.Models.Element();
          _OccurrenceString.DeserializeJson(ref reader, options);
          break;

        case "patient":
          Patient = new fhirCsR5.Models.Reference();
          Patient.DeserializeJson(ref reader, options);
          break;

        case "performer":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Performer = new List<ImmunizationPerformer>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ImmunizationPerformer objPerformer = new fhirCsR5.Models.ImmunizationPerformer();
            objPerformer.DeserializeJson(ref reader, options);
            Performer.Add(objPerformer);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Performer.Count == 0)
          {
            Performer = null;
          }

          break;

        case "primarySource":
          PrimarySource = reader.GetBoolean();
          break;

        case "programEligibility":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ProgramEligibility = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objProgramEligibility = new fhirCsR5.Models.CodeableConcept();
            objProgramEligibility.DeserializeJson(ref reader, options);
            ProgramEligibility.Add(objProgramEligibility);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ProgramEligibility.Count == 0)
          {
            ProgramEligibility = null;
          }

          break;

        case "protocolApplied":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          ProtocolApplied = new List<ImmunizationProtocolApplied>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ImmunizationProtocolApplied objProtocolApplied = new fhirCsR5.Models.ImmunizationProtocolApplied();
            objProtocolApplied.DeserializeJson(ref reader, options);
            ProtocolApplied.Add(objProtocolApplied);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (ProtocolApplied.Count == 0)
          {
            ProtocolApplied = null;
          }

          break;

        case "reaction":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Reaction = new List<ImmunizationReaction>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.ImmunizationReaction objReaction = new fhirCsR5.Models.ImmunizationReaction();
            objReaction.DeserializeJson(ref reader, options);
            Reaction.Add(objReaction);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Reaction.Count == 0)
          {
            Reaction = null;
          }

          break;

        case "reason":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Reason = new List<CodeableReference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableReference objReason = new fhirCsR5.Models.CodeableReference();
            objReason.DeserializeJson(ref reader, options);
            Reason.Add(objReason);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Reason.Count == 0)
          {
            Reason = null;
          }

          break;

        case "recorded":
          Recorded = reader.GetString();
          break;

        case "_recorded":
          _Recorded = new fhirCsR5.Models.Element();
          _Recorded.DeserializeJson(ref reader, options);
          break;

        case "route":
          Route = new fhirCsR5.Models.CodeableConcept();
          Route.DeserializeJson(ref reader, options);
          break;

        case "site":
          Site = new fhirCsR5.Models.CodeableConcept();
          Site.DeserializeJson(ref reader, options);
          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR5.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "statusReason":
          StatusReason = new fhirCsR5.Models.CodeableConcept();
          StatusReason.DeserializeJson(ref reader, options);
          break;

        case "subpotentReason":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          SubpotentReason = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objSubpotentReason = new fhirCsR5.Models.CodeableConcept();
            objSubpotentReason.DeserializeJson(ref reader, options);
            SubpotentReason.Add(objSubpotentReason);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (SubpotentReason.Count == 0)
          {
            SubpotentReason = null;
          }

          break;

        case "vaccineCode":
          VaccineCode = new fhirCsR5.Models.CodeableConcept();
          VaccineCode.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the Immunization.status field
  /// </summary>
  public static class ImmunizationStatusCodes {
    public const string COMPLETED = "completed";
    public const string ENTERED_IN_ERROR = "entered-in-error";
    public const string NOT_DONE = "not-done";
  }
}
