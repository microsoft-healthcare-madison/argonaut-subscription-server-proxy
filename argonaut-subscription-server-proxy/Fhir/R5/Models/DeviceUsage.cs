// <auto-generated />
// Built from: hl7.fhir.r5.core version: 4.6.0
  // Option: "NAMESPACE" = "fhirCsR5"

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Text.Json.Serialization;
using fhirCsR5.Serialization;

namespace fhirCsR5.Models
{
  /// <summary>
  /// A record of a device being used by a patient where the record is the result of a report from the patient or a clinician.
  /// </summary>
  [JsonConverter(typeof(fhirCsR5.Serialization.JsonStreamComponentConverter<DeviceUsage>))]
  public class DeviceUsage : DomainResource,  IFhirJsonSerializable {
    /// <summary>
    /// Resource Type Name
    /// </summary>
    public override string ResourceType => "DeviceUsage";
    /// <summary>
    /// A plan, proposal or order that is fulfilled in whole or in part by this DeviceUsage.
    /// </summary>
    public List<Reference> BasedOn { get; set; }
    /// <summary>
    /// Indicates the anotomic location on the subject's body where the device was used ( i.e. the target).
    /// </summary>
    public CodeableReference BodySite { get; set; }
    /// <summary>
    /// This attribute indicates a category for the statement - The device statement may be made in an inpatient or outpatient settting (inpatient | outpatient | community | patientspecified).
    /// </summary>
    public List<CodeableConcept> Category { get; set; }
    /// <summary>
    /// The encounter or episode of care that establishes the context for this device use statement.
    /// </summary>
    public Reference Context { get; set; }
    /// <summary>
    /// The time at which the statement was recorded by informationSource.
    /// </summary>
    public string DateAsserted { get; set; }
    /// <summary>
    /// Extension container element for DateAsserted
    /// </summary>
    public Element _DateAsserted { get; set; }
    /// <summary>
    /// The most common use cases for deriving a DeviceUsage comes from creating it from a request or from an observation or a claim. it should be noted that the amount of information that is available varies from the type resource that you derive the DeviceUsage from.
    /// </summary>
    public List<Reference> DerivedFrom { get; set; }
    /// <summary>
    /// Code or Reference to device used.
    /// </summary>
    public CodeableReference Device { get; set; }
    /// <summary>
    /// An external identifier for this statement such as an IRI.
    /// </summary>
    public List<Identifier> Identifier { get; set; }
    /// <summary>
    /// Who reported the device was being used by the patient.
    /// </summary>
    public Reference InformationSource { get; set; }
    /// <summary>
    /// Details about the device statement that were not represented at all or sufficiently in one of the attributes provided in a class. These may include for example a comment, an instruction, or a note associated with the statement.
    /// </summary>
    public List<Annotation> Note { get; set; }
    /// <summary>
    /// When the status is not done, the reason code indicates why it was not done.
    /// </summary>
    public List<CodeableReference> Reason { get; set; }
    /// <summary>
    /// DeviceUseStatment is a statement at a point in time.  The status is only representative at the point when it was asserted.  The value set for contains codes that assert the status of the use  by the patient (for example, stopped or on hold) as well as codes that assert the status of the resource itself (for example, entered in error).
    /// This element is labeled as a modifier because the status contains the codes that mark the statement as not currently valid.
    /// </summary>
    public string Status { get; set; }
    /// <summary>
    /// Extension container element for Status
    /// </summary>
    public Element _Status { get; set; }
    /// <summary>
    /// The patient who used the device.
    /// </summary>
    public Reference Subject { get; set; }
    /// <summary>
    /// How often the device was used.
    /// </summary>
    public Timing TimingTiming { get; set; }
    /// <summary>
    /// How often the device was used.
    /// </summary>
    public Period TimingPeriod { get; set; }
    /// <summary>
    /// How often the device was used.
    /// </summary>
    public string TimingDateTime { get; set; }
    /// <summary>
    /// Extension container element for TimingDateTime
    /// </summary>
    public Element _TimingDateTime { get; set; }
    /// <summary>
    /// The reason for asserting the usage status - for example forgot, lost, stolen, broken.
    /// </summary>
    public List<CodeableConcept> UsageReason { get; set; }
    /// <summary>
    /// The status of the device usage, for example always, sometimes, never. This is not the same as the status of the statement.
    /// </summary>
    public CodeableConcept UsageStatus { get; set; }
    /// <summary>
    /// Serialize to a JSON object
    /// </summary>
    public new void SerializeJson(Utf8JsonWriter writer, JsonSerializerOptions options, bool includeStartObject = true)
    {
      if (includeStartObject)
      {
        writer.WriteStartObject();
      }
      if (!string.IsNullOrEmpty(ResourceType))
      {
        writer.WriteString("resourceType", (string)ResourceType!);
      }


      ((fhirCsR5.Models.DomainResource)this).SerializeJson(writer, options, false);

      if ((Identifier != null) && (Identifier.Count != 0))
      {
        writer.WritePropertyName("identifier");
        writer.WriteStartArray();

        foreach (Identifier valIdentifier in Identifier)
        {
          valIdentifier.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if ((BasedOn != null) && (BasedOn.Count != 0))
      {
        writer.WritePropertyName("basedOn");
        writer.WriteStartArray();

        foreach (Reference valBasedOn in BasedOn)
        {
          valBasedOn.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (!string.IsNullOrEmpty(Status))
      {
        writer.WriteString("status", (string)Status!);
      }

      if (_Status != null)
      {
        writer.WritePropertyName("_status");
        _Status.SerializeJson(writer, options);
      }

      if ((Category != null) && (Category.Count != 0))
      {
        writer.WritePropertyName("category");
        writer.WriteStartArray();

        foreach (CodeableConcept valCategory in Category)
        {
          valCategory.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Subject != null)
      {
        writer.WritePropertyName("subject");
        Subject.SerializeJson(writer, options);
      }

      if ((DerivedFrom != null) && (DerivedFrom.Count != 0))
      {
        writer.WritePropertyName("derivedFrom");
        writer.WriteStartArray();

        foreach (Reference valDerivedFrom in DerivedFrom)
        {
          valDerivedFrom.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (Context != null)
      {
        writer.WritePropertyName("context");
        Context.SerializeJson(writer, options);
      }

      if (TimingTiming != null)
      {
        writer.WritePropertyName("timingTiming");
        TimingTiming.SerializeJson(writer, options);
      }

      if (TimingPeriod != null)
      {
        writer.WritePropertyName("timingPeriod");
        TimingPeriod.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(TimingDateTime))
      {
        writer.WriteString("timingDateTime", (string)TimingDateTime!);
      }

      if (_TimingDateTime != null)
      {
        writer.WritePropertyName("_timingDateTime");
        _TimingDateTime.SerializeJson(writer, options);
      }

      if (!string.IsNullOrEmpty(DateAsserted))
      {
        writer.WriteString("dateAsserted", (string)DateAsserted!);
      }

      if (_DateAsserted != null)
      {
        writer.WritePropertyName("_dateAsserted");
        _DateAsserted.SerializeJson(writer, options);
      }

      if (UsageStatus != null)
      {
        writer.WritePropertyName("usageStatus");
        UsageStatus.SerializeJson(writer, options);
      }

      if ((UsageReason != null) && (UsageReason.Count != 0))
      {
        writer.WritePropertyName("usageReason");
        writer.WriteStartArray();

        foreach (CodeableConcept valUsageReason in UsageReason)
        {
          valUsageReason.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (InformationSource != null)
      {
        writer.WritePropertyName("informationSource");
        InformationSource.SerializeJson(writer, options);
      }

      if (Device != null)
      {
        writer.WritePropertyName("device");
        Device.SerializeJson(writer, options);
      }

      if ((Reason != null) && (Reason.Count != 0))
      {
        writer.WritePropertyName("reason");
        writer.WriteStartArray();

        foreach (CodeableReference valReason in Reason)
        {
          valReason.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (BodySite != null)
      {
        writer.WritePropertyName("bodySite");
        BodySite.SerializeJson(writer, options);
      }

      if ((Note != null) && (Note.Count != 0))
      {
        writer.WritePropertyName("note");
        writer.WriteStartArray();

        foreach (Annotation valNote in Note)
        {
          valNote.SerializeJson(writer, options, true);
        }

        writer.WriteEndArray();
      }

      if (includeStartObject)
      {
        writer.WriteEndObject();
      }
    }
    /// <summary>
    /// Deserialize a JSON property
    /// </summary>
    public new void DeserializeJsonProperty(ref Utf8JsonReader reader, JsonSerializerOptions options, string propertyName)
    {
      switch (propertyName)
      {
        case "basedOn":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          BasedOn = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objBasedOn = new fhirCsR5.Models.Reference();
            objBasedOn.DeserializeJson(ref reader, options);
            BasedOn.Add(objBasedOn);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (BasedOn.Count == 0)
          {
            BasedOn = null;
          }

          break;

        case "bodySite":
          BodySite = new fhirCsR5.Models.CodeableReference();
          BodySite.DeserializeJson(ref reader, options);
          break;

        case "category":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Category = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objCategory = new fhirCsR5.Models.CodeableConcept();
            objCategory.DeserializeJson(ref reader, options);
            Category.Add(objCategory);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Category.Count == 0)
          {
            Category = null;
          }

          break;

        case "context":
          Context = new fhirCsR5.Models.Reference();
          Context.DeserializeJson(ref reader, options);
          break;

        case "dateAsserted":
          DateAsserted = reader.GetString();
          break;

        case "_dateAsserted":
          _DateAsserted = new fhirCsR5.Models.Element();
          _DateAsserted.DeserializeJson(ref reader, options);
          break;

        case "derivedFrom":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          DerivedFrom = new List<Reference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Reference objDerivedFrom = new fhirCsR5.Models.Reference();
            objDerivedFrom.DeserializeJson(ref reader, options);
            DerivedFrom.Add(objDerivedFrom);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (DerivedFrom.Count == 0)
          {
            DerivedFrom = null;
          }

          break;

        case "device":
          Device = new fhirCsR5.Models.CodeableReference();
          Device.DeserializeJson(ref reader, options);
          break;

        case "identifier":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Identifier = new List<Identifier>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Identifier objIdentifier = new fhirCsR5.Models.Identifier();
            objIdentifier.DeserializeJson(ref reader, options);
            Identifier.Add(objIdentifier);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Identifier.Count == 0)
          {
            Identifier = null;
          }

          break;

        case "informationSource":
          InformationSource = new fhirCsR5.Models.Reference();
          InformationSource.DeserializeJson(ref reader, options);
          break;

        case "note":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Note = new List<Annotation>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.Annotation objNote = new fhirCsR5.Models.Annotation();
            objNote.DeserializeJson(ref reader, options);
            Note.Add(objNote);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Note.Count == 0)
          {
            Note = null;
          }

          break;

        case "reason":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          Reason = new List<CodeableReference>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableReference objReason = new fhirCsR5.Models.CodeableReference();
            objReason.DeserializeJson(ref reader, options);
            Reason.Add(objReason);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (Reason.Count == 0)
          {
            Reason = null;
          }

          break;

        case "status":
          Status = reader.GetString();
          break;

        case "_status":
          _Status = new fhirCsR5.Models.Element();
          _Status.DeserializeJson(ref reader, options);
          break;

        case "subject":
          Subject = new fhirCsR5.Models.Reference();
          Subject.DeserializeJson(ref reader, options);
          break;

        case "timingTiming":
          TimingTiming = new fhirCsR5.Models.Timing();
          TimingTiming.DeserializeJson(ref reader, options);
          break;

        case "timingPeriod":
          TimingPeriod = new fhirCsR5.Models.Period();
          TimingPeriod.DeserializeJson(ref reader, options);
          break;

        case "timingDateTime":
          TimingDateTime = reader.GetString();
          break;

        case "_timingDateTime":
          _TimingDateTime = new fhirCsR5.Models.Element();
          _TimingDateTime.DeserializeJson(ref reader, options);
          break;

        case "usageReason":
          if ((reader.TokenType != JsonTokenType.StartArray) || (!reader.Read()))
          {
            throw new JsonException();
          }

          UsageReason = new List<CodeableConcept>();

          while (reader.TokenType != JsonTokenType.EndArray)
          {
            fhirCsR5.Models.CodeableConcept objUsageReason = new fhirCsR5.Models.CodeableConcept();
            objUsageReason.DeserializeJson(ref reader, options);
            UsageReason.Add(objUsageReason);

            if (!reader.Read())
            {
              throw new JsonException();
            }
          }

          if (UsageReason.Count == 0)
          {
            UsageReason = null;
          }

          break;

        case "usageStatus":
          UsageStatus = new fhirCsR5.Models.CodeableConcept();
          UsageStatus.DeserializeJson(ref reader, options);
          break;

        default:
          ((fhirCsR5.Models.DomainResource)this).DeserializeJsonProperty(ref reader, options, propertyName);
          break;
      }
    }

    /// <summary>
    /// Deserialize a JSON object
    /// </summary>
    public new void DeserializeJson(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
      string propertyName;

      while (reader.Read())
      {
        if (reader.TokenType == JsonTokenType.EndObject)
        {
          return;
        }

        if (reader.TokenType == JsonTokenType.PropertyName)
        {
          propertyName = reader.GetString();
          reader.Read();
          this.DeserializeJsonProperty(ref reader, options, propertyName);
        }
      }

      throw new JsonException();
    }
  }
  /// <summary>
  /// Code Values for the DeviceUsage.status field
  /// </summary>
  public static class DeviceUsageStatusCodes {
    public const string ACTIVE = "active";
    public const string COMPLETED = "completed";
    public const string ENTERED_IN_ERROR = "entered-in-error";
    public const string INTENDED = "intended";
    public const string STOPPED = "stopped";
    public const string ON_HOLD = "on-hold";
  }
}
